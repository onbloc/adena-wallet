import { ContractMessage } from '@inject/types';

export function mappedTransactionMessages(
  messages: {
    type: string;
    value: any;
  }[],
): ContractMessage[] {
  return messages
    .map((message) => {
      switch (message.type) {
        case '/bank.MsgSend':
          return {
            type: '/bank.MsgSend',
            value: message.value,
          };
        case '/vm.m_call':
          return {
            type: '/vm.m_call',
            value: message.value,
          };
        case '/vm.m_addpkg':
          return {
            type: '/vm.m_addpkg',
            value: message.value,
          };
        case '/vm.m_run':
          return {
            type: '/vm.m_run',
            value: message.value,
          };
      }
      return null;
    })
    .filter((message) => message !== null) as ContractMessage[];
}

/**
 * Maps the messages in the Transaction Document.
 * Since caller information does not exist in messages generated by tx link,
 * it is set to the current address information received as a parameter.
 *
 * @param messages
 * @param caller
 * @returns
 */
export function mappedDocumentMessagesWithCaller(
  messages: any[],
  currentAddress: string,
): ContractMessage[] {
  if (!messages) {
    return [];
  }

  return messages
    .map((message) => {
      const type = message.type;
      switch (type) {
        case '/bank.MsgSend':
          return {
            ...message,
            value: {
              ...message.value,
              from_address: message.value.from_address || currentAddress,
            },
          };
        case '/vm.m_call':
          return {
            ...message,
            value: {
              ...message.value,
              caller: message.value.caller || currentAddress,
            },
          };
        case '/vm.m_addpkg':
          return {
            ...message,
            value: {
              ...message.value,
              creator: message.value.creator || currentAddress,
            },
          };
        case '/vm.m_run':
          return {
            ...message,
            value: {
              ...message.value,
              caller: message.value.caller || currentAddress,
            },
          };
      }
      return null;
    })
    .filter((message) => message !== null) as any[];
}
